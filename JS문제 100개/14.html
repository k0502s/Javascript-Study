<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
    </head>
    <body>
        <script>
            //66. 블럭탑 쌓기
            // 탑을 쌓기 위해 각 크기별로 준비된 블럭들을 정해진 순서에 맞게 쌓아야 합니다.
            // 순서에 맞게 쌓지 않으면 무너질 수 있습니다.

            // 예를 들면 정해진 순서가 BAC 라면 A 다음 C가 쌓아져야 합니다.
            // 선행으로 쌓아야 하는 블럭이 만족된 경우라면 탑이 무너지지 않습니다.

            // - B를 쌓지 않아도 A와 C를 쌓을 수 있습니다.
            // - B 다음 블럭이 C가 될 수 있습니다.

            // 쌓아져 있는 블럭 탑이 순서에 맞게 쌓아져 있는지 확인하세요.

            // 1. 블럭은 알파벳 대문자로 표기합니다.
            // 2. 규칙에 없는 블럭이 사용될 수 있습니다.
            // 3. 중복된 블럭은 존재하지 않습니다.

            // 입력
            // 탑 = ["ABCDEF", "BCAD", "ADEFQRX", "BEDFG", "EFGHZ"]
            // 규칙 = "ABD"

            // 출력
            // ["가능", "불가능", "가능", "가능", "가능"]

            // const solution = (전체블록, 규칙) => {
            //     let answer = [];
            //     for (let 부분블록 of 전체블록) {
            //         answer.push(블록순서체크(부분블록, 규칙));
            //     }
            //     return answer;
            // };

            // const 블록순서체크 = (부분블록, 규칙) => {
            //     let 임시변수 = 규칙.indexOf(규칙[0]);
            //     for (let 문자 of 부분블록) {
            //         if (규칙.includes(문자)) {
            //             if (임시변수 > 규칙.indexOf(문자)) {
            //                 return '불가능';
            //             }
            //             임시변수 = 규칙.indexOf(문자);
            //         }
            //     }
            //     return '가능';
            // };

            // const 전체블록 = ['ABCDEF', 'BCAD', 'ADEFQRX', 'BEDFG', 'AEBFDGCH'];
            // const 규칙 = 'ABCD';

            // console.log(solution(전체블록, 규칙));
            //["가능", "불가능", "가능", "가능", "불가능"]

            //67. 악수
            // 광장에서 모인 사람들과 악수를 하는 행사가 열렸습니다.
            // 참가자인 민규는 몇명의 사람들과 악수를 한 후 중간에 일이 생겨 집으로 갔습니다.

            // 이 행사에서 진행된 악수는 총 n번이라고 했을 때,
            // 민규는 몇 번의 악수를 하고 집으로 돌아갔을까요?
            // 그리고 민규를 포함한 행사 참가자는 몇 명일까요?

            // - 악수는 모두 1대 1로 진행이 됩니다.
            // - 민규를 제외한 모든 참가자는 자신을 제외한 참가자와 모두 한번씩
            //악수를 합니다.
            // - 같은 상대와 중복된 악수는 카운트 하지 않습니다.
            // - 민규를 제외한 참가자는 행사를 모두 마쳤습니다.

            // 예를들어 행사에서 59회의 악수가 진행되었다면 민규는 4번의 악수를 하였고
            //민규를 포함한 참가자는 12명이다.

            // 행사에서 진행된 악수 횟수(n)를 입력으로 받으면 민규의 악수 횟수와
            //행사 참가자 수가 출력됩니다.

            // 입력
            // 59

            // 출력
            // [4, 12] // [악수 횟수, 행사 참가자 수]

            // const solution = (n) => {
            //     let 사람 = 0;
            //     let 총악수 = 0;
            //     let temp = 0;
            //     while (true) {
            //         총악수 = parseInt((사람 * (사람 - 1)) / 2, 10);
            //         if (n < 총악수) {
            //             break;
            //         }
            //         temp = 총악수;
            //         사람 += 1;
            //     }
            //     return [parseInt(n - temp, 10), 사람];
            // }

            // const 악수의수 = 59;
            // console.log(solution(악수의수));

            //68. 버스 시간표

            //버스 시간표와 현재 시간이 주어졌을 때 버스 도착 시간이
            //얼마나 남았는지 알려주는 프로그램을 만들어주세요.

            // - 버스 시간표와 현재 시간이 입력으로 주어집니다.
            // - 출력 포맷은 "00시 00분"입니다.
            //만약 1시간 3분이 남았다면 "01시간 03분"으로 출력해야 합니다.
            // - 버스 시간표에 현재 시간보다 이전인 버스가 있다면 "지나갔습니다."
            //라고 출력합니다.

            // 입력
            // ["12:30", "13:20", "14:13"]
            // "12:40"

            // 출력
            // ['지나갔습니다', '00시간 40분', '01시간 33분']

            //60으로 곱해줘야지 시간당 기준을 잡고 60을 나누어서 시간과 분을 나누어 구할 수 있음
            // const solution = (버스시간, 기준시간) => {
            //     let answer = [];
            //     기준시간 = 기준시간.split(':').map((n) => parseInt(n, 10));
            //     기준시간 = 기준시간[0] * 60 + 기준시간[1];

            //     for (let i in 버스시간) {
            //         let time = 버스시간[i].split(':').map((n) => parseInt(n, 10));
            //         time = time[0] * 60 + time[1];

            //         if (time < 기준시간) {
            //             answer.push('지나갔습니다');
            //         } else {
            //             let 시간 = parseInt((time - 기준시간) / 60, 10);
            //             let 분 = (time - 기준시간) % 60;
            //             answer.push(String(시간).padStart(2, 0) + '시간 '
            //              + String(분).padStart(2, 0) + '분');
            //         }
            //     }
            //     return answer;
            // }

            // console.log(solution(['12:30', '13:20', '14:13'], '12:40'));

            //69. 골드바흐의 추측(Goldbach's conjecture)은 오래전부터 알려진 정수론의 미해결 문제로,
            //2보다 큰 모든 짝수는 두 개의 소수(Prime number)의 합으로 표시할 수 있다는 것이다.
            //이때 하나의 소수를 두 번 사용하는 것은 허용한다. - 위키백과

            // 위 설명에서 2보다 큰 모든 짝수를 두 소수의 합으로 나타낸 것을 골드바흐 파티션이라고
            // 합니다.

            // 예)
            // 100 == 47 + 53
            // 56 == 19 + 37

            // 2보다 큰 짝수 n이 주어졌을 때, 골드바흐 파티션을 출력하는 코드를 작성하세요.

            // 소수 구하기
            // let prime = [];
            // let isPrime = true;

            // for (let i = 2; i < 100; i++) {
            //     for (let j = 2; j < i; j++) {
            //         if (i % j == 0) {
            //             isPrime = false;
            //         }
            //     }
            //     if (isPrime) {
            //         prime.push(i);
            //     }
            //     isPrime = true;
            // }

            // let val = parseInt(prompt('숫자를 입력하세요:'), 10);

            // let 골드바흐파티션 = [];

            // for (let n of prime) {
            //     if (prime.includes(val - n) && n <= val - n) {
            //         골드바흐파티션.push([n, val - n]);
            //     }
            // }

            // let 차 = 골드바흐파티션.map((e) => e[1] - e[0]);

            // let 작은값 = 골드바흐파티션[차.indexOf(Math.min.apply(null, 차))];
            // let 큰값 = 골드바흐파티션[차.indexOf(Math.max.apply(null, 차))];

            // console.log(골드바흐파티션);
            // console.log(작은값);
            // console.log(큰값);

            // 70. 행렬 곱하기
            // 행렬 2개가 주어졌을 때 곱할 수 있는 행렬인지 확인하고 곱할 수 있다면
            //그 결과를 출력하고,
            // 곱할 수 없다면 -1을 출력하는 프로그램을 만들어주세요.

            // 입력
            // a = [[1, 2],
            // 		[2, 4]]

            // b = [[1, 0],
            // 		[0, 3]]

            // 출력
            // [[1, 6], [2, 12]]

            // const solution = (a, b) => {
            //     let c = [];
            //     const len = a[0].length;

            //     // a와 b의 배열 갯수와 배열 속 값 갯수과 일치해야 곱셈 가능하도록 if 조건 함
            //     if (len === b.length) {
            //         //행렬의 곱셉 코드
            //         for (let i = 0; i < len; i++) {
            //             let row = [];
            //             for (let j = 0; j < len; j++) {
            //                 let x = 0;
            //                 for (let k = 0; k < len; k++) {
            //                     x += a[i][k] * b[k][j];
            //                 }
            //                 console.log(x)
            //                 row.push(x);
            //             }
            //             c.push(row);
            //         }
            //         return c;
            //     } else {
            //         return -1;
            //     }
            // }

            // const a = [
            //     [1, 2],
            //     [2, 4],
            // ];
            // const b = [
            //     [1, 0],
            //     [0, 3],
            // ];

            // console.log(solution(a, b));
        </script>
    </body>
</html>
