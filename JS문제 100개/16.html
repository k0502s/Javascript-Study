<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
    </head>
    <body>
        <script>
            // //76. 가장 먼저 테스트 케이스의 수를 나타내는 1이상 100 이하의 자연수가 주어진다.
            // 각 테스트 케이스의 첫 줄에는 수색할 도시의 크기 a와 수색반이 한 번에 수색 가능한 범위 b가
            // 주어진다. (a와 b 모두 정사각형의 가로 또는 세로를 나타낸다. 예를 들어 10이 주어지면 10x10
            // 칸의 크기를 나타낸다.)

            // 그 후 a 줄에 걸쳐 도시 내 지뢰가 있는지의 여부가 나타난다.
            // 0은 지뢰가 없음 1은 지뢰가 있음을 뜻한다.

            // 각 테스트 케이스에 대해 수색 가능한 범위 bxb 내에서 찾아낼 수 있는 가장 큰 지뢰의 개수를
            // 구하라.

            // 입력
            // 1
            // 5 3
            // 1 0 0 1 0
            // 0 1 0 0 1
            // 0 0 0 1 0
            // 0 0 0 0 0
            // 0 0 1 0 0

            // 출력
            // 3

            // let 사각형 = 5;
            // let 탐색가능지역 = 3;
            // let 지뢰밭 = [
            //     [1, 0, 0, 1, 0],
            //     [0, 1, 0, 0, 1],
            //     [0, 0, 0, 1, 0],
            //     [0, 0, 0, 0, 0],
            //     [0, 0, 1, 0, 0],
            // ];

            // let iadd = 0;
            // let jadd = 0;
            // let value = 0;
            // let valueArray = [];
            // for (let iadd = 0; iadd <= 사각형 - 탐색가능지역; iadd++) {
            //     for (let jadd = 0; jadd <= 사각형 - 탐색가능지역; jadd++) {
            //         for (let i = iadd; i <= 탐색가능지역 - 1 + iadd; i++) {
            //             for (let j = jadd; j <= 탐색가능지역 - 1 + jadd; j++) {
            //                 // console.log(i, j);
            //                 value += 지뢰밭[i][j];
            //             }
            //         }
            //         valueArray.push(value);
            //         console.log('---------');
            //         value = 0;
            //     }
            //     console.log('!!!!!!!');
            // }

            // console.log(valueArray);
            // console.log(Math.max.apply(null, valueArray));

            //77. 가장 긴 공통 부분 문자열(Longest Common Subsequence)이란 A, B 두 문자열이
            //주어졌을 때 두 열에 공통으로 들어 있는 요소로 만들 수 있는 가장 긴 부분열을 말
            //합니다. 여기서 부분열이란 다른 문자열에서 몇몇의 문자가 빠져 있어도 순서가
            //바뀌지 않은 열을 말합니다.

            // 예를 들어 S1 = ['T', 'H', 'I', 'S', 'I', 'S', 'S', 'T', 'R', 'I', 'N', 'G', 'S']
            // S2 = ['T', 'H', 'I', 'S', 'I', 'S']라는 두 문자열이 있을 때 둘 사이의 부분 공통 문자열의
            // 길이는 ['T', 'H', 'I', 'S', 'I', 'S']의 6개가 됩니다.

            // 이처럼 두 문자열이 주어지면 가장 긴 부분 공통 문자열의 길이를 반환하는 프로그램을 만들어
            // 주세요.

            // 두 개의 문자열이 한 줄에 하나씩 주어집니다. 문자열은 알파벳 대문자로만 구성되며
            // 그 길이는 100글자가 넘어가지 않습니다.

            // 출력은 이 두 문자열의 가장 긴 부분 공통 문자열의 길이를 반환하면 됩니다.

            // 입력
            // THISISSTRINGS
            // THISIS

            // 출력
            // 6

            // const sol = (string) => {
            //     let result = [];
            //     for (let i = 1; i < string.length + 1; i++) {
            //         for (let j = 0; j < i; j++) {
            //             result.push(string.slice(j, j + string.length - i + 1));
            //         }
            //     }
            //     return result;

            // }

            // const inputOne = prompt('첫번째 문자열을 입력해주세요.');
            // const inputTwo = prompt('두번째 문자열을 입력해주세요.');
            // const arrayOne = sol(inputOne);
            // console.log(arrayOne)
            // const arrayTwo = sol(inputTwo);
            // console.log(arrayTwo)

            // //공통 부분 문자열 찾기- 교집합
            // let intersection = arrayOne.filter((x) => arrayTwo.includes(x));

            // //문자열 길이로 내림차순 정렬
            // intersection.sort((a, b) => {
            //     return b.length - a.length;
            // });
            // console.log(intersection)
            // console.log(intersection[0].length);

            //78. 원형 테이블
            // 기린은 배가 너무 고파 혼자 음식을 먹기 시작합니다. 원형 테이블에는
            // N 개의 음식들이 있습니다.
            // 한 개의 음식을 다 먹으면 그 음식의 시계방향으로 K 번째 음식을 먹습니다.
            // 하지만 아직 오지 않은 친구들을 위해 2개의 접시를 남겨야 합니다.

            // 마지막으로 남는 음식은 어떤 접시인가요?
            // 입력은 2개의 정수로 이루어지며 공백으로 구분되어 입력됩니다.
            // 첫 번째 숫자가 음식의 개수 N, 두 번째 숫자가 K입니다.
            // 첫 번째 가져가는 음식이 K 번째 음식이며 나머지는 첫 번째 음식으로부터
            //시계방향으로 가져갑니다.

            // 입력
            // 6 3

            // 남은 음식들의 번호를 배열의 형태로 출력합니다.

            // 출력
            // [3, 5]

            // const user_input = prompt('입력해주세요').split(' ');
            // const n = parseInt(user_input[0], 10);
            // const k = parseInt(user_input[1], 10);

            // const sol = (n, k) => {
            //     let index = 0;
            //     // q에 n만큼의 숫자를 넣어준다.
            //     let q = [];
            //     for (let i = 0; i < n; i++) {
            //         q.push(i + 1);
            //     }

            //     while (q.length > 2) {
            //         if (index > q.length - 1) {
            //             // 순환하다 index가 q의 길이보다 클 경우에 q.length만큼 빼준다.
            //             // [1,2,3,4,5,6] -> 1다음 4가 빠지고 그 다음은 4+3 = 7(index : 6)이 빠져야 하는데
            //             // index(현재 빠져야 할 index)가 q.length보다 크므로 q.legnth, 즉 4를 빼준다.
            //             // 이걸 마지막 2개가 남을 때까지 반복한다.
            //             index -= q.length;
            //         }

            //         q.splice(index, 1);
            //         index += k;
            //         index -= 1;
            //     }

            //     return q;
            // }

            // console.log(sol(n, k));

            //79. 순회하는 리스트

            // 변하기 전 원소와 변한 후 원소의 값의 차가 가장 작은 값을 출력하는
            // 프로그램을 작성하세요.

            // 예를 들어 2번 순회했을 때 변하기 전의 리스트와 변한 후의 리스트의 값은
            // 아래와 같습니다.

            // 순회전_리스트 = [10, 20, 25, 27, 34, 35, 39]
            // 순회후_리스트 = [35, 39, 10, 20, 25, 27, 34]
            // 리스트의_차 = [25, 19, 15, 7, 9, 8, 5]

            // 39와 변한 후의 34 값의 차가 5이므로 리스트의 차 중 최솟값입니다.
            // 따라서 39와 34의 인덱스인 6과 39와 34를 출력하는 프로그램을 만들어주세요.

            // 입력
            // 순회횟수는 : 2

            // 출력
            // index : 6
            // value : 39, 34

            // const l = [10, 20, 25, 27, 34, 35, 39]; //기존 입력 값
            // const n = parseInt(prompt('순회횟수는?'), 10);

            // const rotate = (a, t) => {
            //     let b = a.slice();
            //     console.log(b)
            //     let c = [];
            //     for (let i = 0; i < t; i++) {
            //         b.unshift(b.pop());
            //     }
            //     console.log(b)

            //     for (let i in a) {
            //         // let i in b 로 해도됩니다.
            //         c.push(Math.abs(a[i] - b[i]));
            //     }
            //     console.log(c)

            //     //최솟값
            //     const m = Math.min.apply(null, c);

            //     //최솟값의 인덱스 구하기
            //     let index = c.indexOf(m);

            //     console.log('index :', index);
            //     console.log('value :', a[index], b[index]);
            // };

            // rotate(l, n);

            //80. 순열과 조합

            // 한글의 자모 24자 중 자음은 총 14개입니다.이 중 입력받은 자음을 n 개를
            // 선택하여 나올 수 있는 모든 조합과, 조합의 수를 출력하고 싶습니다.

            // ‘한글 맞춤법’의 제2장 제4항에서는 한글의 기본 자모 24자 “ㄱ(기역), ㄴ(니은),
            // ㄷ(디귿), ㄹ(리을), ㅁ(미음), ㅂ(비읍), ㅅ(시옷), ㅇ(이응), ㅈ(지읒), ㅊ(치읓)
            // , ㅋ(키읔), ㅌ(티읕), ㅍ(피읖), ㅎ(히읗), ㅏ(아), ㅑ(야), ㅓ(어), ㅕ(여),
            // ㅗ(오), ㅛ(요), ㅜ(우), ㅠ(유), ㅡ(으), ㅣ(이)”를 제시

            //<--요구 조건-->
            // 1. 첫 번째 입력으로 선택할 한글 자음이 주어집니다.
            // 2. 두 번째 입력으로 조합의 수가 주어집니다.
            // 3. 주어진 조합의 수에 따라 조합과 조합의 수를 출력해 주세요.

            // 입력
            // ㄱ,ㄴ,ㄷ,ㄹ
            // 3

            // 출력
            // ['ㄱㄴㄷ', 'ㄱㄴㄹ', 'ㄱㄷㄹ', 'ㄴㄷㄹ']
            // 4
            
            // const combination = (chars) => {
            //     let combi = [];

            //     const f = (prefix, chars) => {
            //         for (let i = 0; i < chars.length; i++) {
            //             combi.push(prefix + chars[i]);

            //             f(prefix + chars[i], chars.slice(i + 1));
            //         }
            //     };

            //     f('', chars);
            //     console.log(combi)

            //     //조합의 수에 맞는 것만 추출!
            //     const result = combi.filter((x) => x.length === n);
            //     console.log(result);

            //     return result.length;
            // };

            // const arr = prompt('입력해주세요').split(',');
            // const n = parseInt(prompt('조합의 수를 입력해주세요'), 10);

            // console.log(combination(arr));
        </script>
    </body>
</html>
