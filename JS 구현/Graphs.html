<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Document</title>
    </head>
    <body>
        <script>
            // 1. Edge List
            const graph = [
                [0, 2],
                [2, 3],
                [2, 1],
                [1, 3],
            ];
            // connection을 보여주고 있는 배열들이다. 각 노드들 간의 연결관계
            // 0은 2와(또는 반대), 2는 3과, 2는 1과, 1은 3과 연결되어 있다는 의미이다.

            // 2. Adjacent List
            const graph2 = [[2], [2, 3], [0, 1, 3], [1, 2]];
            // index는 Node를 가리키고, value는 Node의 Neighbor를 가리키는 형태
            // 0번째 index의 노드는 2와 이웃, 1번째 index의 노드는 2, 3과 이웃,
            // 2번째 index의 노드는 0, 1, 3과 이웃, 3번째 index의 노드는 1, 2와 이웃
            // 배열 말고 Hash Table 또는 Linked List로 만들 수도 있다.

            // 3-1. Adjacent Matrix
            const graph3 = [
                [0, 0, 1, 0], // 0번째 index는 2번째 index 와 연결
                [0, 0, 1, 1], // Node 1은 Node 2, 3과 연결
                [1, 1, 0, 1], // Node 2는 Node 0, 1, 3과 연결
                [0, 1, 1, 0], // Node 3은 Node 1, 2와 연결
            ];

            // 3-2. Adjacent Matrix
            const graph4 = {
                0: [0, 0, 1, 0], // 0번째 index는 2번째 index 와 연결
                1: [0, 0, 1, 1], // Node 1은 Node 2, 3과 연결
                2: [1, 1, 0, 1], // Node 2는 Node 0, 1, 3과 연결
                3: [0, 1, 1, 0], // Node 3은 Node 1, 2와 연결
            };
            // graph3과 graph4는 동일한 표현방식이다. 배열로 표현했느냐, 객체로 표현했느냐의 차이일 뿐이다.

            // Graphs method Implementation
            class Graph {
                constructor() {
                    this.numberOfNodes = 0;
                    this.adjacentList = {};
                }
                addVertex(node) {}
                addEdge(node1, node2) {
                    //undirected Graph
                }
                showConnections() {
                    const allNodes = Object.keys(this.adjacentList);
                    for (let node of allNodes) {
                        let nodeConnections = this.adjacentList[node];
                        let connections = '';
                        let vertex;
                        for (vertex of nodeConnections) {
                            connections += vertex + ' ';
                        }
                        console.log(node + '-->' + connections);
                    }
                }
            }

            const myGraph = new Graph();
            myGraph.addVertex('0');
            myGraph.addVertex('1');
            myGraph.addVertex('2');
            myGraph.addVertex('3');
            myGraph.addVertex('4');
            myGraph.addVertex('5');
            myGraph.addVertex('6');
            myGraph.addEdge('3', '1');
            myGraph.addEdge('3', '4');
            myGraph.addEdge('4', '2');
            myGraph.addEdge('4', '5');
            myGraph.addEdge('1', '2');
            myGraph.addEdge('1', '0');
            myGraph.addEdge('0', '2');
            myGraph.addEdge('6', '5');

            myGraph.showConnections();
            //Answer:
            // 0-->1 2
            // 1-->3 2 0
            // 2-->4 1 0
            // 3-->1 4
            // 4-->3 2 5
            // 5-->4 6
            // 6-->5
        </script>
    </body>
</html>
